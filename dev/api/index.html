<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ReverseDiff.jl</title><meta name="title" content="API · ReverseDiff.jl"/><meta property="og:title" content="API · ReverseDiff.jl"/><meta property="twitter:title" content="API · ReverseDiff.jl"/><meta name="description" content="Documentation for ReverseDiff.jl."/><meta property="og:description" content="Documentation for ReverseDiff.jl."/><meta property="twitter:description" content="Documentation for ReverseDiff.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ReverseDiff.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../limits/">Limitation of ReverseDiff</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Gradients-of-f(x::AbstractArray{:Real}...)::Real"><span>Gradients of <code>f(x::AbstractArray{&lt;:Real}...)::Real</code></span></a></li><li><a class="tocitem" href="#Jacobians-of-f(x::AbstractArray{:Real}...)::AbstractArray{:Real}"><span>Jacobians of <code>f(x::AbstractArray{&lt;:Real}...)::AbstractArray{&lt;:Real}</code></span></a></li><li><a class="tocitem" href="#Hessians-of-f(x::AbstractArray{:Real})::Real"><span>Hessians of <code>f(x::AbstractArray{&lt;:Real})::Real</code></span></a></li><li><a class="tocitem" href="#The-AbstractTape-API"><span>The <code>AbstractTape</code> API</span></a></li><li><a class="tocitem" href="#The-AbstractConfig-API"><span>The <code>AbstractConfig</code> API</span></a></li><li><a class="tocitem" href="#Optimization-Annotations"><span>Optimization Annotations</span></a></li><li><a class="tocitem" href="#ChainRules-integration"><span>ChainRules integration</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDiff/ReverseDiff.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ReverseDiff-API"><a class="docs-heading-anchor" href="#ReverseDiff-API">ReverseDiff API</a><a id="ReverseDiff-API-1"></a><a class="docs-heading-anchor-permalink" href="#ReverseDiff-API" title="Permalink"></a></h1><h2 id="Gradients-of-f(x::AbstractArray{:Real}...)::Real"><a class="docs-heading-anchor" href="#Gradients-of-f(x::AbstractArray{:Real}...)::Real">Gradients of <code>f(x::AbstractArray{&lt;:Real}...)::Real</code></a><a id="Gradients-of-f(x::AbstractArray{:Real}...)::Real-1"></a><a class="docs-heading-anchor-permalink" href="#Gradients-of-f(x::AbstractArray{:Real}...)::Real" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.gradient" href="#ReverseDiff.gradient"><code>ReverseDiff.gradient</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.gradient(f, input, cfg::GradientConfig = GradientConfig(input))</code></pre><p>If <code>input</code> is an <code>AbstractArray</code>, assume <code>f</code> has the form <code>f(::AbstractArray{&lt;:Real})::Real</code> and return <code>∇f(input)</code>.</p><p>If <code>input</code> is a tuple of <code>AbstractArray</code>s, assume <code>f</code> has the form <code>f(::AbstractArray{&lt;:Real}...)::Real</code> (such that it can be called as <code>f(input...)</code>) and return a <code>Tuple</code> where the <code>i</code>th element is the gradient of <code>f</code> w.r.t. <code>input[i].</code></p><p>Note that <code>cfg</code> can be preallocated and reused for subsequent calls.</p><p>If possible, it is highly recommended to use <code>ReverseDiff.GradientTape</code> to prerecord <code>f</code>. Otherwise, this method will have to re-record <code>f</code>&#39;s execution trace for every subsequent call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/gradients.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.gradient!" href="#ReverseDiff.gradient!"><code>ReverseDiff.gradient!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.gradient!(result, f, input, cfg::GradientConfig = GradientConfig(input))</code></pre><p>Returns <code>result</code>. This method is exactly like <code>ReverseDiff.gradient(f, input, cfg)</code>, except it stores the resulting gradient(s) in <code>result</code> rather than allocating new memory.</p><p><code>result</code> can be an <code>AbstractArray</code> or a <code>Tuple</code> of <code>AbstractArray</code>s. The <code>result</code> (or any of its elements, if <code>isa(result, Tuple)</code>), can also be a <code>DiffResults.DiffResult</code>, in which case the primal value <code>f(input)</code> (or <code>f(input...)</code>, if <code>isa(input, Tuple)</code>) will be stored in it as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/gradients.jl#L29-L39">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.gradient!(tape::Union{GradientTape,CompiledGradient}, input)</code></pre><p>If <code>input</code> is an <code>AbstractArray</code>, assume <code>tape</code> represents a function of the form <code>f(::AbstractArray)::Real</code> and return <code>∇f(input)</code>.</p><p>If <code>input</code> is a tuple of <code>AbstractArray</code>s, assume <code>tape</code> represents a function of the form <code>f(::AbstractArray...)::Real</code> and return a <code>Tuple</code> where the <code>i</code>th element is the gradient of <code>f</code> w.r.t. <code>input[i].</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/gradients.jl#L51-L60">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.gradient!(result, tape::Union{GradientTape,CompiledGradient}, input)</code></pre><p>Returns <code>result</code>. This method is exactly like <code>ReverseDiff.gradient!(tape, input)</code>, except it stores the resulting gradient(s) in <code>result</code> rather than allocating new memory.</p><p><code>result</code> can be an <code>AbstractArray</code> or a <code>Tuple</code> of <code>AbstractArray</code>s. The <code>result</code> (or any of its elements, if <code>isa(result, Tuple)</code>), can also be a <code>DiffResults.DiffResult</code>, in which case the primal value <code>f(input)</code> (or <code>f(input...)</code>, if <code>isa(input, Tuple)</code>) will be stored in it as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/gradients.jl#L67-L77">source</a></section></article><h2 id="Jacobians-of-f(x::AbstractArray{:Real}...)::AbstractArray{:Real}"><a class="docs-heading-anchor" href="#Jacobians-of-f(x::AbstractArray{:Real}...)::AbstractArray{:Real}">Jacobians of <code>f(x::AbstractArray{&lt;:Real}...)::AbstractArray{&lt;:Real}</code></a><a id="Jacobians-of-f(x::AbstractArray{:Real}...)::AbstractArray{:Real}-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobians-of-f(x::AbstractArray{:Real}...)::AbstractArray{:Real}" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.jacobian" href="#ReverseDiff.jacobian"><code>ReverseDiff.jacobian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.jacobian(f, input, cfg::JacobianConfig = JacobianConfig(input))</code></pre><p>If <code>input</code> is an <code>AbstractArray</code>, assume <code>f</code> has the form <code>f(::AbstractArray{&lt;:Real})::AbstractArray{&lt;:Real}</code> and return <code>J(f)(input)</code>.</p><p>If <code>input</code> is a tuple of <code>AbstractArray</code>s, assume <code>f</code> has the form <code>f(::AbstractArray{&lt;:Real}...)::AbstractArray{&lt;:Real}</code> (such that it can be called as <code>f(input...)</code>) and return a <code>Tuple</code> where the <code>i</code>th element is the  Jacobian of <code>f</code> w.r.t. <code>input[i].</code></p><p>Note that <code>cfg</code> can be preallocated and reused for subsequent calls.</p><p>If possible, it is highly recommended to use <code>ReverseDiff.JacobianTape</code> to prerecord <code>f</code>. Otherwise, this method will have to re-record <code>f</code>&#39;s execution trace for every subsequent call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/jacobians.jl#L5-L21">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.jacobian(f!, output, input, cfg::JacobianConfig = JacobianConfig(output, input))</code></pre><p>Exactly like <code>ReverseDiff.jacobian(f, input, cfg)</code>, except the target function has the form <code>f!(output::AbstractArray{&lt;:Real}, input::AbstractArray{&lt;:Real}...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/jacobians.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.jacobian!" href="#ReverseDiff.jacobian!"><code>ReverseDiff.jacobian!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.jacobian!(result, f, input, cfg::JacobianConfig = JacobianConfig(input))</code></pre><p>Returns <code>result</code>. This method is exactly like <code>ReverseDiff.jacobian(f, input, cfg)</code>, except it stores the resulting Jacobian(s) in <code>result</code> rather than allocating new memory.</p><p><code>result</code> can be an <code>AbstractArray</code> or a <code>Tuple</code> of <code>AbstractArray</code>s. The <code>result</code> (or any of its elements, if <code>isa(result, Tuple)</code>), can also be a <code>DiffResults.DiffResult</code>, in which case the primal value <code>f(input)</code> (or <code>f(input...)</code>, if <code>isa(input, Tuple)</code>) will be stored in it as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/jacobians.jl#L30-L40">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.jacobian!(result, f!, output, input, cfg::JacobianConfig = JacobianConfig(output, input))</code></pre><p>Exactly like <code>ReverseDiff.jacobian!(result, f, input, cfg)</code>, except the target function has the form <code>f!(output::AbstractArray{&lt;:Real}, input::AbstractArray{&lt;:Real}...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/jacobians.jl#L68-L73">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.jacobian!(tape::Union{JacobianTape,CompiledJacobian}, input)</code></pre><p>If <code>input</code> is an <code>AbstractArray</code>, assume <code>tape</code> represents a function of the form <code>f(::AbstractArray{&lt;:Real})::AbstractArray{&lt;:Real}</code> or <code>f!(::AbstractArray{&lt;:Real}, ::AbstractArray{&lt;:Real})</code> and return <code>tape</code>&#39;s Jacobian w.r.t. <code>input</code>.</p><p>If <code>input</code> is a tuple of <code>AbstractArray</code>s, assume <code>tape</code> represents a function of the form <code>f(::AbstractArray{&lt;:Real}...)::AbstractArray{&lt;:Real}</code> or <code>f!(::AbstractArray{&lt;:Real}, ::AbstractArray{&lt;:Real}...)</code> and return a <code>Tuple</code> where the <code>i</code>th element is <code>tape</code>&#39;s Jacobian w.r.t. <code>input[i].</code></p><p>Note that if <code>tape</code> represents a function of the form <code>f!(output, input...)</code>, you can only execute <code>tape</code> with new <code>input</code> values. There is no way to re-run <code>tape</code>&#39;s tape with new <code>output</code> values; since <code>f!</code> can mutate <code>output</code>, there exists no stable &quot;hook&quot; for loading new <code>output</code> values into the tape.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/jacobians.jl#L87-L103">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.jacobian!(result, tape::Union{JacobianTape,CompiledJacobian}, input)</code></pre><p>Returns <code>result</code>. This method is exactly like <code>ReverseDiff.jacobian!(tape, input)</code>, except it stores the resulting Jacobian(s) in <code>result</code> rather than allocating new memory.</p><p><code>result</code> can be an <code>AbstractArray</code> or a <code>Tuple</code> of <code>AbstractArray</code>s. The <code>result</code> (or any of its elements, if <code>isa(result, Tuple)</code>), can also be a <code>DiffResults.DiffResult</code>, in which case the primal value of the target function will be stored in it as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/jacobians.jl#L110-L119">source</a></section></article><h2 id="Hessians-of-f(x::AbstractArray{:Real})::Real"><a class="docs-heading-anchor" href="#Hessians-of-f(x::AbstractArray{:Real})::Real">Hessians of <code>f(x::AbstractArray{&lt;:Real})::Real</code></a><a id="Hessians-of-f(x::AbstractArray{:Real})::Real-1"></a><a class="docs-heading-anchor-permalink" href="#Hessians-of-f(x::AbstractArray{:Real})::Real" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.hessian" href="#ReverseDiff.hessian"><code>ReverseDiff.hessian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.hessian(f, input::AbstractArray, cfg::HessianConfig = HessianConfig(input))</code></pre><p>Given <code>f(input::AbstractArray{&lt;:Real})::Real</code>, return <code>f</code>s Hessian w.r.t. to the given <code>input</code>.</p><p>Note that <code>cfg</code> can be preallocated and reused for subsequent calls.</p><p>If possible, it is highly recommended to use <code>ReverseDiff.HessianTape</code> to prerecord <code>f</code>. Otherwise, this method will have to re-record <code>f</code>&#39;s execution trace for every subsequent call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/hessians.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.hessian!" href="#ReverseDiff.hessian!"><code>ReverseDiff.hessian!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.hessian!(result::AbstractArray, f, input::AbstractArray, cfg::HessianConfig = HessianConfig(input))

ReverseDiff.hessian!(result::DiffResult, f, input::AbstractArray, cfg::HessianConfig = HessianConfig(result, input))</code></pre><p>Returns <code>result</code>. This method is exactly like <code>ReverseDiff.hessian(f, input, cfg)</code>, except it stores the resulting Hessian in <code>result</code> rather than allocating new memory.</p><p>If <code>result</code> is a <code>DiffResults.DiffResult</code>, the primal value <code>f(input)</code> and the gradient <code>∇f(input)</code> will be stored in it along with the Hessian <code>H(f)(input)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/hessians.jl#L28-L38">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.hessian!(tape::Union{HessianTape,CompiledHessian}, input)</code></pre><p>Assuming <code>tape</code> represents a function of the form <code>f(::AbstractArray{&lt;:Real})::Real</code>, return the Hessian <code>H(f)(input)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/hessians.jl#L63-L68">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.hessian!(result::AbstractArray, tape::Union{HessianTape,CompiledHessian}, input)

ReverseDiff.hessian!(result::DiffResult, tape::Union{HessianTape,CompiledHessian}, input)</code></pre><p>Returns <code>result</code>. This method is exactly like <code>ReverseDiff.hessian!(tape, input)</code>, except it stores the resulting Hessian in <code>result</code> rather than allocating new memory.</p><p>If <code>result</code> is a <code>DiffResults.DiffResult</code>, the primal value <code>f(input)</code> and the gradient <code>∇f(input)</code> will be stored in it along with the Hessian <code>H(f)(input)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/hessians.jl#L75-L85">source</a></section></article><h2 id="The-AbstractTape-API"><a class="docs-heading-anchor" href="#The-AbstractTape-API">The <code>AbstractTape</code> API</a><a id="The-AbstractTape-API-1"></a><a class="docs-heading-anchor-permalink" href="#The-AbstractTape-API" title="Permalink"></a></h2><p>ReverseDiff works by recording the target function&#39;s execution trace to a &quot;tape&quot;, then running the tape forwards and backwards to propagate new input values and derivative information.</p><p>In many cases, it is the recording phase of this process that consumes the most time and memory, while the forward and reverse execution passes are often fast and non-allocating. Luckily, ReverseDiff provides the <code>AbstractTape</code> family of types, which enable the user to <em>pre-record</em> a reusable tape for a given function and differentiation operation.</p><p><strong>Note that pre-recording a tape can only capture the the execution trace of the target function with the given input values.</strong> Therefore, re-running the tape (even with new input values) will only execute the paths that were recorded using the original input values. In other words, the tape cannot any re-enact branching behavior that depends on the input values. You can guarantee your own safety in this regard by never using the <code>AbstractTape</code> API with functions that contain control flow based on the input values.</p><p>Similarly to the branching issue, a tape is not guaranteed to capture any side-effects caused or depended on by the target function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.GradientTape" href="#ReverseDiff.GradientTape"><code>ReverseDiff.GradientTape</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.GradientTape(f, input, cfg::GradientConfig = GradientConfig(input))</code></pre><p>Return a <code>GradientTape</code> instance containing a pre-recorded execution trace of <code>f</code> at the given <code>input</code>.</p><p>This <code>GradientTape</code> can then be passed to <code>ReverseDiff.gradient!</code> to take gradients of the execution trace with new <code>input</code> values. Note that these new values must have the same element type and shape as <code>input</code>.</p><p>See <code>ReverseDiff.gradient</code> for a description of acceptable types for <code>input</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/tape.jl#L185-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.JacobianTape" href="#ReverseDiff.JacobianTape"><code>ReverseDiff.JacobianTape</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.JacobianTape(f, input, cfg::JacobianConfig = JacobianConfig(input))</code></pre><p>Return a <code>JacobianTape</code> instance containing a pre-recorded execution trace of <code>f</code> at the given <code>input</code>.</p><p>This <code>JacobianTape</code> can then be passed to <code>ReverseDiff.jacobian!</code> to take Jacobians of the execution trace with new <code>input</code> values. Note that these new values must have the same element type and shape as <code>input</code>.</p><p>See <code>ReverseDiff.jacobian</code> for a description of acceptable types for <code>input</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/tape.jl#L215-L226">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.JacobianTape(f!, output, input, cfg::JacobianConfig = JacobianConfig(output, input))</code></pre><p>Return a <code>JacobianTape</code> instance containing a pre-recorded execution trace of <code>f</code> at the given <code>output</code> and <code>input</code>.</p><p>This <code>JacobianTape</code> can then be passed to <code>ReverseDiff.jacobian!</code> to take Jacobians of the execution trace with new <code>input</code> values. Note that these new values must have the same element type and shape as <code>input</code>.</p><p>See <code>ReverseDiff.jacobian</code> for a description of acceptable types for <code>input</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/tape.jl#L241-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.HessianTape" href="#ReverseDiff.HessianTape"><code>ReverseDiff.HessianTape</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.HessianTape(f, input, cfg::HessianConfig = HessianConfig(input))</code></pre><p>Return a <code>HessianTape</code> instance containing a pre-recorded execution trace of <code>f</code> at the given <code>input</code>.</p><p>This <code>HessianTape</code> can then be passed to <code>ReverseDiff.hessian!</code> to take Hessians of the execution trace with new <code>input</code> values. Note that these new values must have the same element type and shape as <code>input</code>.</p><p>See <code>ReverseDiff.hessian</code> for a description of acceptable types for <code>input</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/tape.jl#L273-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.compile" href="#ReverseDiff.compile"><code>ReverseDiff.compile</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.compile(t::AbstractTape)</code></pre><p>Return a fully compiled representation of <code>t</code> of type <code>CompiledTape</code>. This object can be passed to any API methods that accept <code>t</code> (e.g. <code>gradient!(result, t, input)</code>).</p><p>In many cases, compiling <code>t</code> can significantly speed up execution time. Note that the longer the tape, the more time compilation may take. Very long tapes (i.e. when <code>length(t)</code> is on the order of 10000 elements) can take a very long time to compile.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/tape.jl#L136-L145">source</a></section></article><h2 id="The-AbstractConfig-API"><a class="docs-heading-anchor" href="#The-AbstractConfig-API">The <code>AbstractConfig</code> API</a><a id="The-AbstractConfig-API-1"></a><a class="docs-heading-anchor-permalink" href="#The-AbstractConfig-API" title="Permalink"></a></h2><p>For the sake of convenience and performance, all &quot;extra&quot; information used by ReverseDiff&#39;s API methods is bundled up in the <code>ReverseDiff.AbstractConfig</code> family of types. These types allow the user to easily feed several different parameters to ReverseDiff&#39;s API methods, such as work buffers and tape configurations.</p><p>ReverseDiff&#39;s basic API methods will allocate these types automatically by default, but you can reduce memory usage and improve performance if you preallocate them yourself.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.GradientConfig" href="#ReverseDiff.GradientConfig"><code>ReverseDiff.GradientConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.GradientConfig(input, tp::InstructionTape = InstructionTape())</code></pre><p>Return a <code>GradientConfig</code> instance containing the preallocated tape and work buffers used by the <code>ReverseDiff.gradient</code>/<code>ReverseDiff.gradient!</code> methods.</p><p>Note that <code>input</code> is only used for type and shape information; it is not stored or modified in any way. It is assumed that the element type of <code>input</code> is same as the element type of the target function&#39;s output.</p><p>See <code>ReverseDiff.gradient</code> for a description of acceptable types for <code>input</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/Config.jl#L23-L34">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.GradientConfig(input, ::Type{D}, tp::InstructionTape = InstructionTape())</code></pre><p>Like <code>GradientConfig(input, tp)</code>, except the provided type <code>D</code> is assumed to be the element type of the target function&#39;s output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/Config.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.JacobianConfig" href="#ReverseDiff.JacobianConfig"><code>ReverseDiff.JacobianConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.JacobianConfig(input, tp::InstructionTape = InstructionTape())</code></pre><p>Return a <code>JacobianConfig</code> instance containing the preallocated tape and work buffers used by the <code>ReverseDiff.jacobian</code>/<code>ReverseDiff.jacobian!</code> methods.</p><p>Note that <code>input</code> is only used for type and shape information; it is not stored or modified in any way. It is assumed that the element type of <code>input</code> is same as the element type of the target function&#39;s output.</p><p>See <code>ReverseDiff.jacobian</code> for a description of acceptable types for <code>input</code>.</p><pre><code class="nohighlight hljs">ReverseDiff.JacobianConfig(input, ::Type{D}, tp::InstructionTape = InstructionTape())</code></pre><p>Like <code>JacobianConfig(input, tp)</code>, except the provided type <code>D</code> is assumed to be the element type of the target function&#39;s output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/Config.jl#L68-L84">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.JacobianConfig(output::AbstractArray, input, tp::InstructionTape = InstructionTape())</code></pre><p>Return a <code>JacobianConfig</code> instance containing the preallocated tape and work buffers used by the <code>ReverseDiff.jacobian</code>/<code>ReverseDiff.jacobian!</code> methods. This method assumes the target function has the form <code>f!(output, input)</code></p><p>Note that <code>input</code> and <code>output</code> are only used for type and shape information; they are not stored or modified in any way.</p><p>See <code>ReverseDiff.jacobian</code> for a description of acceptable types for <code>input</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/Config.jl#L90-L101">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.JacobianConfig(result::DiffResults.DiffResult, input, tp::InstructionTape = InstructionTape())</code></pre><p>A convenience method for <code>JacobianConfig(DiffResults.value(result), input, tp)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/Config.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.HessianConfig" href="#ReverseDiff.HessianConfig"><code>ReverseDiff.HessianConfig</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.HessianConfig(input::AbstractArray, gtp::InstructionTape = InstructionTape(), jtp::InstructionTape = InstructionTape())</code></pre><p>Return a <code>HessianConfig</code> instance containing the preallocated tape and work buffers used by the <code>ReverseDiff.hessian</code>/<code>ReverseDiff.hessian!</code> methods. <code>gtp</code> is the tape used for the inner gradient calculation, while <code>jtp</code> is used for outer Jacobian calculation.</p><p>Note that <code>input</code> is only used for type and shape information; it is not stored or modified in any way. It is assumed that the element type of <code>input</code> is same as the element type of the target function&#39;s output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/Config.jl#L131-L141">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.HessianConfig(input::AbstractArray, ::Type{D}, gtp::InstructionTape = InstructionTape(), jtp::InstructionTape = InstructionTape())</code></pre><p>Like <code>HessianConfig(input, tp)</code>, except the provided type <code>D</code> is assumed to be the element type of the target function&#39;s output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/Config.jl#L146-L151">source</a></section><section><div><pre><code class="language-julia hljs">ReverseDiff.HessianConfig(result::DiffResults.DiffResult, input::AbstractArray, gtp::InstructionTape = InstructionTape(), jtp::InstructionTape = InstructionTape())</code></pre><p>Like <code>HessianConfig(input, tp)</code>, but utilize <code>result</code> along with <code>input</code> to construct work buffers.</p><p>Note that <code>result</code> and <code>input</code> are only used for type and shape information; they are not stored or modified in any way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/api/Config.jl#L158-L166">source</a></section></article><h2 id="Optimization-Annotations"><a class="docs-heading-anchor" href="#Optimization-Annotations">Optimization Annotations</a><a id="Optimization-Annotations-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Annotations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.@forward" href="#ReverseDiff.@forward"><code>ReverseDiff.@forward</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.@forward(f)(args::Real...)
ReverseDiff.@forward f(args::Real...) = ...
ReverseDiff.@forward f = (args::Real...) -&gt; ...</code></pre><p>Declare that the given function should be differentiated using forward mode automatic differentiation. Note that the macro can be used at either the definition site or at the call site of <code>f</code>. Currently, only <code>length(args) &lt;= 2</code> is supported. <strong>Note that, if <code>f</code> is defined within another function <code>g</code>, <code>f</code> should not close over any differentiable input of <code>g</code>.</strong> By using this macro, you are providing a guarantee that this property holds true.</p><p>This macro can be very beneficial for performance when intermediate functions in your computation are low dimensional scalar functions, because it minimizes the number of instructions that must be recorded to the tape. For example, take the function <code>sigmoid(n) = 1. / (1. + exp(-n))</code>. Normally, using ReverseDiff to differentiate this function would require recording 4 instructions (<code>-</code>, <code>exp</code>, <code>+</code>, and <code>/</code>). However, if we apply the <code>@forward</code> macro, only one instruction will be recorded (<code>sigmoid</code>). The <code>sigmoid</code> function will then be differentiated using ForwardDiff&#39;s <code>Dual</code> number type.</p><p>This is also beneficial for higher-order elementwise function application. ReverseDiff overloads <code>map</code>/<code>broadcast</code> to dispatch on <code>@forward</code>-applied functions. For example, <code>map(@forward(f), x)</code> will usually be more performant than <code>map(f, x)</code>.</p><p>ReverseDiff overloads many Base scalar functions to behave as <code>@forward</code> functions by default. A full list is given by <code>DiffRules.diffrules()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/macros.jl#L46-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.@skip" href="#ReverseDiff.@skip"><code>ReverseDiff.@skip</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseDiff.@skip(f)(args::Real...)
ReverseDiff.@skip f(args::Real...) = ...
ReverseDiff.@skip f = (args::Real...) -&gt; ...</code></pre><p>Declare that the given function should be skipped during the instruction-recording phase of differentiation. Note that the macro can be used at either the definition site or at the call site of <code>f</code>. <strong>Note that, if <code>f</code> is defined within another function <code>g</code>, <code>f</code> should not close over any differentiable input of <code>g</code>.</strong> By using this macro, you are providing a guarantee that this property holds true.</p><p>ReverseDiff overloads many Base scalar functions to behave as <code>@skip</code> functions by default. A full list is given by <code>ReverseDiff.SKIPPED_UNARY_SCALAR_FUNCS</code> and <code>ReverseDiff.SKIPPED_BINARY_SCALAR_FUNCS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/macros.jl#L146-L160">source</a></section></article><h2 id="ChainRules-integration"><a class="docs-heading-anchor" href="#ChainRules-integration">ChainRules integration</a><a id="ChainRules-integration-1"></a><a class="docs-heading-anchor-permalink" href="#ChainRules-integration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ReverseDiff.@grad_from_chainrules" href="#ReverseDiff.@grad_from_chainrules"><code>ReverseDiff.@grad_from_chainrules</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">@grad_from_chainrules f(args...; kwargs...)</code></pre><p>The <code>@grad_from_chainrules</code> macro provides a way to import adjoints(rrule) defined in ChainRules to ReverseDiff. One must provide a method signature to import the corresponding <code>rrule</code>. In the provided method signature, one should replace the types of arguments to which one wants to take derivatives with respect with <code>ReverseDiff.TrackedReal</code> and <code>ReverseDiff.TrackedArray</code> respectively. For example, we can import <code>rrule</code> of <code>f(x::Real, y::Array)</code> like below:</p><pre><code class="language-julia hljs">ReverseDiff.@grad_from_chainrules f(x::TrackedReal, y::TrackedArray)
ReverseDiff.@grad_from_chainrules f(x::TrackedReal, y::Array)
ReverseDiff.@grad_from_chainrules f(x::Real, y::TrackedArray)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDiff/ReverseDiff.jl/blob/90f1516120c136f468ce7e5dd0bcf0257d8f42a6/src/macros.jl#L298-L315">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../limits/">« Limitation of ReverseDiff</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Friday 28 March 2025 15:27">Friday 28 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
